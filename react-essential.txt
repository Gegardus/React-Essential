Working with useEffect

Another important hook that's part of the react library is useEffect. UseEffect is another one of these hooks that is built into react. And this one can feel a little bit tricky because it's typically used to manage side effects that aren't related to a components render. Things like console messages, loading data, and working with animations can often benefit from useEffect. So let's take a basic look at useEffect with a console log. So the first thing we want to do, we'll import useEffect from react and then we're going to use inside of our app component this useEffect hook. Now this time, instead of setting this equal to some sort of array, we're going to pass in a function to this. So we'll go ahead and say console log, it's emotion right now. So now we'll see that this will log this message to our console. We think about this as being a side effect. It's not necessarily going to be affected by the render but instead it's going to be something that just happens alongside the render. Now, something else to note here is useEffect actually takes into arguments. The first is this function that's going to be called whenever we want our effect to happen. But the second has to do with when the effect is actually being called. We're going to pass into this an empty array. If you pass in an empty array, this means that the effect is not going to be called again after the first render. So, it's only going to be called once as soon as the component renders, but not as we change this emotion. We call this array, the dependency array because we can use it to define when this should be called. Should it just be called once when our component first renders or another option is we could pass in a property, a state value, to listen for any changes in this array. So check this out. If I refresh, it's happy right now. If I click it again, excited, sad. Anytime this emotion changes, we're going to see this useEffect fire. Now in the next video, we'll do some more tweaks with this to really get an understanding of how this dependency array actually works.


Understanding the dependency array

It's also possible to use our useEffect calls and our useState calls to keep track of different variables. So let's go ahead and create another one of these. We're going to call this secondary and setSecondary, meaning emotion, and then we're going to say useState, and our initial state is tired. Very possible to be happy and tired all at once. I always am. So what we're going to do here is we're going to add another button. That's going to trigger this change. So, setEmotion. Let's go ahead and put one next door. We'll say h2 Current secondary emotion is secondary. And now, we'll say Grateful. So, now, we're going to add an onClick. Remember that this should trigger this change, setSecondary. And we'll go ahead and trigger that here. We'll say setSecondary and pass in a new emotion, which will be grateful. Perfect. So, now, this should work. Now, this is great for handling different emotions, but we also want to make use of our useEffect here. The point that I'm getting to, I swear, I have a point, is to make sure that we're keeping track of these emotions, and we're making sure to trigger these emotional changes when appropriate. So, check this out. We'll say useEffect, we'll pass in our helper function or callback function here, we'll say console.log, and we'll say it's secondary around here. Now, if I don't pass in that dependency array, we're going to notice that, as soon as I start to make these changes, trigger these emotions, we're going to get it's tired around here for every single one. If we pass in that empty array, remember this will just call this useEffect when our component first renders. So, no matter how many emotions I change, we won't see it's tired again. Now, if we were to say secondary here, this is going to call that anytime that emotion changes. Now, something else to keep in mind is you could pass more than one of these into the dependency array. You could pass more than one of these state variables if you wanted to. So let's say you wanted to anytime the secondary emotion changed and the initial emotion changed, we want to call this function. Well, we can do it. We could say sad, excited, and then, if I say grateful, then we're going to see both of these actually rendering. So the dependency array, very important. Make sure that you don't forget to include it when you're calling useEffect.


Incorporating useReducer

The next thing I want to do here is, let's create a check box that's going to manage state with useState. So, we'll get rid of our useEffect call here. We will get rid of all of our state management stuff. Then we're going to, within our return statement, we're going to, inside of this div, add an input. The input is going to have a type of checkbox, and so we should see that there. Let's also display a label. And for now we'll just have it say, "checked." Okay. So, we'll zoom way in on that for now. And what we want to do is create a checked variable. We'll say, "checked" and "setChecked," and that should be set equal to useState, and the initial state is false. We're going to use this checked value to manage the state of the checkbox, so we want to use value here. And now every time I change the status, I want this to change the output. So, we're going to call onChange, we will call setChecked, and then we'll take a look at whatever the value of checked is and we will return the opposite. So now, we want to have our label reflect that change. So, inside of the label, we'll check to see if checked is true. If so, we want it to read, "checked;" otherwise, we want it to read, "not checked." So, on first render, checked is false. Now, if I toggle this, it should work. So this is a good way of being able to handle our checkbox using useState, but I want to update this a little bit because I think that this could be a little better. And by a little better, I mean it would be cool if we could extract this functionality into a separate function so that we don't have to manage this inside of our onChange. So, let's go ahead and change this. And the change we'll make is to use a different hook, to use a different hook function called useReducer. useReducer is going to take in two different arguments; the first is the function that we're going to use to update our state. So, that's just going to be placed right here. And then the second argument is going to be our initial state. So let's go ahead and we'll save that. We will get our onChange under control. Now, our onChange is going to take in the name of the function that we'll use to update the state. So we'll say, "setChecked." We'll give that a save. Now we can see this a little bit better. Remember, the function that we used to update the state is here, and then the initial state is here. As far as our output goes, the output is going to be exactly the same. But what's nice is that we don't have all of that extra code being written in the onChange that could potentially lead to bugs, and this is going to ensure that any time we call the setChecked function, the results are going to be the same.

Working with uncontrolled components with useRef

One of the most important things to think about when we're working on a React project is how are we going to handle form inputs? Right now, we're dealing with this checkbox, which is a little toggle here but let's say we wanted to collect some different information. So what I want to do here is I want to set this up. I want to get rid of useReducer. I want to instead incorporate another one of these hooks called useRef. A ref or a reference is a way that we can reach out to an individual element and check in with what its value is. So we're going to use this in our app. And we're going to create our first React form. In it, we'll have an input. This time it'll be type equals text and we'll call this a placeholder. We'll say color title. And then the other type of input that we're going to use is a color input. So if you haven't worked with this one before, it's pretty cool. It's an input that's going to collect some sort of color value. So the other thing I need to add here is a button. The button will just say Add and we are going to inside of this App function create another function called submit. We're going to prevent the default behavior of the form with preventDefault. So we'll prevent the page from refreshing here. Once I've created this submit function, we're going to forward the form, add a handler called onSubmit, and basically any time the form submits, we want to do whatever is part of this function. So here's where those refs come into play. I want to be able to reach out to this and grab the name of the color, as well as the color itself. Now, the way that we'll do this is we're going to us txtTitle. We'll set that equal to useRef and then we'll say hexColor. And we'll also set that equal to useRef. So what are these values? Let's take a look at it in the console. We should see an object here and the object has this key on it called current. So think of the current as being whatever the value of this field might be at any given time. We're going to attach these references to these inputs. So the first ref will be called txtTitle. And the second ref hexColor. So now if I try that again, we should see the object again and the current input has a value. So that's really what I'm curious about here. I want to reach out to figure out what the current value of the text field, as well as our color. So we'll do that here. We're going to create a variable called Title, which we'll set equal to whatever the txtTitle.current.value is. Same with the color. So we'll say const color equals hexColor.current.value. Then we're going to alert whatever these values are. So I'll just say title, color. Perfect, so now, if we say purple, we find purple here. And we click Add. We should see both the value, as well as that color. Now, another little cleanup thing we might want to do is we can, once we click OK, we'll see that purple and the color purple are still here. So txtTitle.current.value, as soon as I alert it, we want to set it back to an empty string. Same with hexColor.current.value. We'll set that equal to an empty string. And now if we try that one more time with say yellow, we get the alert, we get those values and then once we click OK, we'll get those cleared out. So think of a useRef as being a hook that is going to reach out to some sort of UI element and get its value. The way that we're handling this form right now, we're creating what's called an uncontrolled component. So we're saying create this little container, give us whatever that value is and something to keep in mind is unlike useState where the component will re-render if there's some sort of a change, useRef is not going to re-render. We always are going to have to reach out to the current value, the current dot value to figure out what that value actually is by reaching out to the input itself.

Building a custom Hook

We've seen how React hooks can add additional functionality to our applications. We can use the state hook to manage state of form fields. We can use ref to reach out to these inputs and figure out their values. And we've also used useEffect to perform side effects. Now, one of the most exciting things about working with hooks is that we can create our own custom hooks that can be used inside of our applications to handle all sorts of different things. So we want to think about our form here, right? We have a form element and the form element has two different inputs. When I type into this input field, there's always going to be some sort of input and then we also want to be able to clear out whatever I've typed into those inputs after I have submitted the form. So there's some kind of repeatable behavior going on here and this is how we're going to think about it when we create our own custom hook. A custom hook is a function and this function is going to always start with the keyword use. So this time for our useInput function, we want to take in some sort of initialValue and we want to inside of this use another one of these useState hooks. So any field, any input is going to take in a value and we're also going to use the setValue function to update that value. And then finally, useState when we call it will take in some sort of initialValue. So what we actually want to return, think of a hook, remember our useState hook returns a pair. useRef is going to return this object. Our hook, and again, this can return whatever you want, is going to return an array. The first item in the array is going to be the state value as well as an onChange, which takes in whatever this input is and calls setValue with the event.target.value. So really similar to what we did with our controlled component. The second item that we're going to pass here is the cleanup function. We'll set the value to whatever that initialValue is. All right, so we'll give that a save. And now within the form, we're going to use useInput. So instead of useState here, we're going to use useInput. Our initialValue is going to be an empty string, and we're going to call this titleProps, so again, it's the value and the onChange. And then then we'll also call the second item resetTitle and this will be colorProps and resetColor. And we'll keep our initialValue as black here. So here we can do some pretty cool cleanup. So we could say titleProps.value, so we want to figure out what that is. colorProps.value. And now we can call resetTitle and we don't actually have to pass anything in here, so we're making this a little bit more reusable. All right, and finally, instead of having our onChange and our value passed in this way, what we're going to do instead is we're going to push in all of the values from titleProps. This is a syntax that we're using to basically spread all of the properties into this input. This is a technique that you should use sort of sparingly but we're okay with it in this case because we know that titleProps is only the value and the onChange. So we'll do the same thing here. We'll get rid of the value, we'll get rid of the onChange and we're okay to use this spread syntax to push in the colorProps because we know we're not pushing in too many properties, we're just pushing in two. Okay, so we have used our useInput hook, our custom hook. And now what we'll do is we'll try to grab purple. We see that pop up and then we clear it out on OK. So this is pretty exciting. We're able to create a custom hook. Remember, a hook is just a function that we can use for any sort of repeatable code. We want to think about a hook as being very reusable. We can share it across our project, we can write tests for this function and then we can use it inside of our form any time we need to process some user input. So think about all of the different form fields that I might create in my lifetime. They always take something in. We handle a change event, we handle resetting that field when we submit the form. So this is really flexible and reusable across projects and across components.

Choosing a form library

In the previous video, we looked at how to use our custom hook, called useInput, to process form element inputs and then reset those values. And we can use this hook across any project that uses forms. There also are a ton of different form libraries that you can reach out to as well. So I wanted to just give you a sense of what a few of these are. The first of these is called Formik, which you can find at formik.org. This is a great way of being able to, basically, handle submitting these forms. We can take in initial values and think about the form holistically as a collection of different fields. There's also a library called React Hook Form, which helps us with creating forms that use validation. Of course, react hooks are in play with this one as well. And there's a lot of cool things in the API for type script and other advanced features that you can use to create some really scalable forms. So I just wanted to point these out to you. I also wanted to pull up another website called useHooks at usehooks.com. This is not form specific, but there are a ton of different resources here, a ton of different hooks that you can think of as being, sort of, like recipes for creating different types of hooks. There are some really common use cases that you'll see here, and you can open all of them in CodeSandbox, so check them out. Formik, React Hook Form, useHooks all are great resources if you want to, kind of, study what they're doing or if you want to incorporate some of these tools into your own projects.

Fetching data with Hooks

Another important thing to know how to do with React is how to fetch data from some external API. So the API that I want to grab some data from is the GitHub API, which you can find at api.github.com/users/ whatever your user ID is. So you can do this for your company, for yourself, whatever you see fit. You would just drop your username after that last slash there. So this is our GitHub REST API that we can use to grab some live data from this source. And what we'll do here is we want to fetch this data using a combination of useState and useEffect. So we're going to use State to handle the data, and we're going to use useEffect to actually make that call for that external data. So in order to get us started here, let's just make sure that our app is working as we expect it to. We want it to say data here. And once I have this ready, we can go ahead and make this fetch. Now inside of our app, we're going to create a container for the data which we'll call data and the function for updating the data will be called setData. Then we're going to say useState. And our initial state for the data will be null. Then we're going to make use of useEffect. And this is where the exciting part happens because we're going to use this fetch call and we're going to fetch from HTTPS api.github.com/users/moonhighway. And again, you can use your own username for that. Fetch is built into the browser. It's supported. It's a way of making an HTTP request to get some data from some sort of source. Once we get that data back, we're going to take that response and we'll call this function called .JSON. So this is going to take whatever the response is and turn it into JSON. And then finally, we're going to chain on another .then function and say setData. So setData here is the same as saying, "Take this data and call setData with the data." But notice that the same value is being sent to this function that setData is being called with. So we can use a shorthand here and call setData that way. The other thing we want to do to use Effect of course is just pass in that empty array, meaning that we should only make a request for this data once when our application first renders. So this is super important, right? We want to make sure we're not making too many API requests. This is something that I've done a million times before, which is to make too many requests to an API. Sometimes I've been blocked by an API because of that, but we know that this should return that data. Now, if we have some data, if data has a value, we're going to return for the moment a pre tag. And this is just a preformatted tag to format some JSON. And we'll say that we want to stringify data, null, and two. Data is the data. And null and two are going to help format this so that we can actually read it out here in our browser. And notice that if there is some data, we're going to display it. Fetching this data with useEffect has allowed us to perform some sort of a side effect. This is more of a real world example outside of a console log, of course, like we saw before. In the next video, we're going to make use of this actual data and create a component.

Handling loading states

When we're fetching data from some sort of external API, our data can be in one of a few different states. So let's talk through what those are. First of all, we have a loading state. So a loading state just means we're fetching the data but it hasn't yet come back. We have a success state where we have some data to display. Then we want to have some sort of an error state if something goes wrong. We can represent all of this with useState hooks. So we have our data here on line 15. Let's also create a value for error and setError. We'll set that equal to useState and initialize with null. Finally, we'll say const loading and setLoading. This will be set equal to useState and our initial state will be false. Okay, so now we need to represent all of these inside of our component. So first things first, we want to scroll down a little bit so that we can in our useEffect model the flow of data into our component. So the first thing we'll do is we're going to setLoading to true. Then we're going to make our fetch a little bit more robust too. So once the data comes back, we'll set the data with that setData function and then we're also going to use this to set our loading state back to false because we have the data. It's no longer loading. And then finally, what's cool about these .then chains is that you can chain on a catch. Catch is going to, if there's some sort of an error, set an error. So now what we want to do here is we want to display our GitHub user component if everything goes as expected. So we're going to get rid of if data. We're going to get ride of this return here. And then above this, we're going to say if loading is true, we want to return an h1 that says loading. Also, if there's an error of any kind, then we want to return a pre-formatted JSON string to display that error. So we'll say error and then we'll say if there's no data, then we'll return null. Perfect. So let's try to refresh this. It's working kind of fast. Our internet is too fast here but once this loads for the first time, it's going to say loading here at the top. Then we're going to see the rest of the data once it's ready. So any sort of asynchronous requests we're making, we need to handle a loading state where we're waiting on that data to come back. We need to handle a success case, as well as an error state. So all of this can be represented using these useState hooks.

Fetching data with GraphQL

We can also use React to fetch data from a GraphQL API. So let's take a look at the GraphQL API that we're going to fetch from. We're going to make a request to this endpoint, snowtooth.moonhighway.com. So if you haven't worked with GraphQL before, just know that GraphQL is a way of creating an API where you can specify what data you want by using its field. So over here is our query. This tool that we're looking at is called the GraphQL playground, and you can use it to send requests much like you do with REST. Instead of grabbing our GitHub user, we're going to call this lift, then with each one of these, we're going to grab its name, elevation gain and status. So here in the h1, we'll say name. We'll say elevationGain, and then we'll say status. Then we can remove our image here. We're basically just going to create one of these lift components for every one of our lifts in our list. So, the place we'll fetch from is this endpoint here, snowtooth.moonhighway.com. There we go. We can keep the rest of the data fetching logic the same. The only thing we would need to change is down here in our return. So if we want to iterate over this data, we're going to need to do this so we're going to first create a div that we want to render here. Then inside of this div, inside of a JSX expression, we'll say data.allLifts.map. For each one of our lifts that we create, we want to return our lift component and the lift component needs a little bit of data, right? So we'll say name, elevationGain=lift.elevationGain. And finally, we'll use status, which is lift.status. Now it's still loading over here. We aren't quite finished because we need to make our fetch request a little bit more robust to send along the body of the query. Right now, we're just saying, hey, give me all the data from this but I need to pass along the query, which would look like this, to actually get all of this information back. So let's go ahead and copy this query. We're going to paste it into our page here. So we'll say const query = and this query should be a string so we'll use backticks around the query. Then we're going to specify some options. So we'll say const opts. The method that we're going to use to send this request is a post request. We're going to specify some headers. So, here we'll say Content-Type application/json and then we'll say body: JSON.stringify the query. So we'll send along that string when we send that request. The final thing we need to do here, now that we have these options, is fetch is going to take in both the URL that we're making the request to and the options. So OPTS. So even though this looks pretty good to me, I'm still not seeing any data coming back. It says loading, and then no data is returned. We also see here that there's some sort of an error 'cause it can't read properties of undefined map. So here's a really interesting thing that's going on here. If we console.log data, and let's call out that that's where that's happening. If we scroll up a little bit, we should see that data is coming back but it's underneath another key called data. So, let's try that. And there we go. Data, data, one of those fun, little fetch request things that's going on, we have to make sure that we are referencing the correct fields on the data that's coming back. Now that we are, we should see all of this data being displayed. So this is a look at how you might use GraphQL with a fetch request inside of a React application. If you are dealing with a GraphQL data source, you can make use of fetch just as you would with a REST API.

Working with render props

The final pattern I want to show you with data loading, has to do with how we use functions to display the right data at the right time. So let me show you what I mean by that. We're going to get rid of most of our code here. We're going to make this way shorter. We're also going to get rid of our map here. So let's just make sure that's working. Perfect. So, let's also create some data here. So I'm going to create a data set called tahoe_peaks that's going to be an array of objects. Each object is going to have its own name and elevation, so 10891. These are real, you can check them out. We'll say Monument Peak, we will set that elevation at 10067. Let's add a couple more of these, name Pyramid. And of course, if you don't feel like typing these, you can always find these in the finished files for this chapter. No shame in copying and pasting. And then finally we'll add Tallac, elevation 9735, 9735. Perfect. So now that we have the elevation in feet, we're going to create a function called List. So this List function is going to be a function that takes in a few different properties, the first of which is data, the second is a function called renderItem, the third is a function called renderEmpty. So renderItem will help us to render an individual list item, and then renderEmpty will be what is displayed if we don't have anything in this list. So let's go ahead and return, we'll say if data.length doesn't exist, so if there's nothing in the data, we want to return the renderEmpty function. Otherwise, we want to return an unordered list where we'll map over the data. So check this out, we'll say data.map for each item, we will return a list item. Sorry, let's save that so we can actually read it, and then we're going to give each list item a key, which will just set to be the item.name, and then we'll say renderItem with whatever that item is. Now it's up to us next to adjust our app, so that it's going to pump the data into the list component in the correct way. So we'll get rid of our div, we'll use the app to render the list. List will have a property called data which we'll set to tahoe_peaks, our list of peaks. We're also going to add renderEmpty. And renderEmpty is just going to render a paragraph, so we'll say, "This list is empty" and then finally we'll say renderItem, and this is going to be a function. So for each item we want to return and check this out, we're going to use a shorthand version of the React fragment. Remember our React fragment from before, we can use this shorthand syntax like we saw, and then inside of this we'll say item.name, and item.elevation, and then we'll say ft. Perfect, so now we are able to see all of this content being displayed. A couple things to think about, we are passing along some JSX to render if the List happens to be empty. So if we got rid of this, the List is empty, pretty cool, renderItem is going to return just this fragment, it'll pass along a little bit of data, so that that can be displayed inside of that list item. So our list and our app components will display any data in a list, no matter how long the list is, and there will even be some fallback content in case we need to render an empty list.

Installing React Router v6

On any website, it's really important to have some sort of mechanism for moving from page to page. Now, with React, we're dealing with different components. So how do we move from component to component when we're dealing with a single-age application? The solution for that is to incorporate React Router. React Router will allow for us to seamlessly move from page to page by displaying different components. React Router is at version six right now, so we're going to go ahead and install this in our project. So let's make sure that we're in the correct folder. We're going to move to the react-app that's in chapter seven, lesson one here, and we're going to go ahead and install, npm install react-router-cdom@6. 

Nesting links with React Router v6

The next step we want to take here is we want to create a child page for our About component that's going to display some information about our company's history. First things first, we'll create a <div>. Inside of that <div> we'll create an h1, and then we'll say Our History. Nice, what a beautiful page. Let's say we wanted to display this as a child of the About page. I want the contents of this to be displayed underneath our About Us. There's a couple steps we need to take to make that happen. The first step is we're going to go back to our route configuration and we're going to nest some routes. So let's go ahead and open our index.js file. And then inside of this Route, inside of the About Route, we're going to close this, and then we're going to put in another Route, and this other Route is going to display that other component. So we'll start with the element because that's the easier part. We'll say History. We also need to import History from the app file. There we go. And then what we want to do for our path is we'll just say path="history", and we'll omit the slash from that. When I click on About, and then when I visit about/history, we're still not seeing that content there. So the step I need to take is I need to open our app .js once more. We're going to import another component from react-router-dom called Outlet. So you want to think about Outlet as being like a little container that's going to display our History component. So here on line 25, we're going to say <Outlet />. So Our History is going to pop up right here. So we're displaying this component as soon as I'm on the page about/history. If I remove /history, we'll just see About Us. And then, if I wanted to, I could link to this as well. A nested route configuration is really a powerful thing because we can then create all sorts of page hierarchies within our application. It's just important to know that, at some level, we want to have our route configuration created. We define all of the paths, and then we create the element property to display the correct component at the correct time.

Using Create React App as a testing platform

So far, we keep using npm start to run our application on local host 3000. But there's a pretty cool built-in feature that is part of Create React App where we can run 

	npm test 

to run all of our tests. So anytime I type npm test, we're going to run any of the tests that are currently in the app. So here in our terminal, we should be able to see that one of these tests has failed. So the test that we're actually seeing run is here in this App.test.js file. And what this is saying is that we expect our screen to say, learn react. Just know that npm test will run anything with that .test.js extension. So right now, this is telling us that our test suite failed to run 'cause our test suite must contain at least one test. So Create React App gives us this mechanism for dealing with running tests. In the next video, we're going to take a look at how we actually write these and connect them to functions that are part of our app.

Testing small functions with Jest

We can start to think about testing with a small example here. So inside of our source folder we want to create two different files. The first is called functions.js, and the second will be called functions.test.js. So we want to think about our functions file as being the place where our code will be written. And then our NPM test command is going to run any test that are part of this file. Create React App already has just configured. So all we need to do is start writing tests. So we're going to write a test using the test function and then the test function is going to have a name as its first argument. So we're going to keep it real simple here. We'll just say multiplies by two. And then it's also going to take in this callback function. So this callback function is going to have another function inside of it called expect. Okay. So the next thing we want to do is let's open up our functions.js file. We'll open this to the side here. So there's side by side. Export default a function called timesTwo and this function is going to just be stubbed for now. And then within our functions test, we need to import this. So we'll say import timesTwo from ./functions. And then here's where we start to write our test. We want to hear call the timesTwo function and we want to pass in four. So even if we haven't written our function yet, we know that if I call the timesTwo function with the value four, I expect the output to be whatever four times two is. So we're going to chain on this function called twoBe and we're going to pass eight here. So we expect anytime I call this function that if given this value, we want to return this value. Let's try to run NPM test. So NPM test should run our tests. Any files that have tests in it. At this moment we should have some sort of an error because it says that timesTwo is not a function because we haven't written it yet. So let's go ahead and fix this. We're going to, within our functions.js file, take in some sort of argument. And then we'll say return a times two. Now, if we save this we're seeing timesTwo is not a function again. And that's because I've imported it wrong. So what we can do to fix this is you either get rid of default and then we should see that passing, or you can keep default and then just import this as the module instead of as the function. What's great about this is that by going through the process of testing, we're seeing, hey, some of our code is problematic. We're exporting things incorrectly and testing will let us know what the problem is. So just to recap, Jest is built in to Create React App. We're using the expect function to figure out what the value of times two is if we call it with four. We're chaining on this matcher here, this Jest matcher. Now, something to keep in mind is that if you take a look at the Jest documentation there are a ton of different matchers that you can make use of, toBe is going to just match for exact equality. But there are others, you could check for values being truthy, falsey, null, you can check for numbers, you can match strings and all sorts of different things. So if you want to take a look at this documentation you don't have to memorize all of this. Thankfully, all of this is well documented on this page.

Introducing React Testing Library

Another test utility that's built directly into create React app is React testing library. So let's take a closer look at how we might use this in our own project. And to do so, we're going to start by creating a new component called Star. And then we'll also create a file called Star.test.js. And remember that Jest is going to run any of these test files if they end in that .test.js extension. So in the Star.js file, we're going to export our function. And our Star is going to display the following. We'll just say Cool Star. So now that I've created that, we're going to open up our Star.test.js. Having things side by side is nice. And we're going to use a function called test to say renders an h1. So remember, we're not actually rendering this to the DOM anywhere. This is a brand new component that we haven't actually rendered. It's important to know that it doesn't matter. We can use these test utilities to actually render this for us. So this is what this will look like. We're going to first import a function called render from @testing-library/react. So let's zoom out a little bit. We will make sure we see all this stuff and now inside of our text, inside of the callback function here, we're going to say const. So we'll destructure from the render of Star what's called a React testing library query. So think of a query as being a way of selecting a particular element based on some sort of a property. So in this case, we're going to say getByText, which is going to, if we create another variable here, so we'll call getByText. So this is going to look for some text that says Cool Star. So here we'll say expect the h1, so we expect this value toHaveTextContent Cool Star. So we're selecting it and then we expect it to have that text. So let's go ahead and run this with npm test. This is going to look for that file and then this is also letting us know that we need to import it. So we're getting helped out all the time with testing. So let's go ahead and import this from Star. And then we should see that this has passed. Just a note too that any time we want to rerun our tests, we can hit A in the terminal and that will rerun all A, the tests. We've been able to render our component without actually having to render it and look at it. We're automating the process of making sure that the right content is in the right place.

Testing events with React Testing Library

Another important part of writing tests is testing events that are part of components. So we're going to go ahead and create a component called Checkbox js and then Checkbox.test.js will house our test. So back to our Checkbox, we remember this one from before, we're going to import useReducer from react. Then we're going to export a function called Checkbox. In it, we're going to have a return here. So we'll say that this fragment should contain a label that reads either checked or unchecked based on the property that we initialize here. So we'll say checked and setChecked should be set equal to useReducer, useReducer takes into arguments. The first is a function that should be called anytime we invoke setChecked. So we should return whatever the opposite of checked is. And then we also want to initialize our state as false whenever this component renders. So we have the label. That's cool. We want to also add our input with the type of checkbox of value of checked and an onChange that will set to setChecked. So now we have our little checkbox component created. So from here, we want to start to write some tests. Back to our Checkbox.test.js. We will go ahead and we'll use our test function from react testing library. We are going to give our test a name. So we'll say selecting the checkbox should change value of checked to true. And then the callback function that we'll send in here should contain our tests. So let's shorten this up a little bit. Selecting checkbox should change value to true. Okay, that's better. We can actually read that. So now we're going to use another one of these queries. So we'll say getByLabelText and we want that to be set equal to render our checkbox. So we need a couple things, right? We need to import render from @testing-library/react. We also need to import our checkbox from that file. So getByLabelText is going to look for whatever we set up in this next value. So we'll say getByLabelText and we expect this to say not checked. And we want to look for any text that says not checked. Now, currently this regx that we're adding here this regular expression is going to look for case sensitivity. So if you wanted to be a little more permissive you could add an 'i' here and that's just going to make sure that it reads not checked, but it could be all caps. It could be the end capitalized, whatever. Here's the exciting part, we knew we were going to get to an exciting part. What we want to do here is we want to automate the process of firing an event on this checkbox. In other words, we want to be able to click on this checkbox. The way we'll do that is by calling fire event. Fire event is a function that will pull in from react testing library. So fireEvent.click. Whenever we click on that checkbox, we expect checkbox.checked to equal true. Let's try to run this and we'll run it in a way that we can read it. NPM test should run all of our existing tests. Okay, so we're getting this error here. It's saying that we found a label with text of and basically this is just an error saying that we need to associate this label with the input. One way that we could do this is we could wrap the label around the input, or you can just say htmlFor checked. And then on the input, you can add an ID of checked. So this should associate the two with one another. This is good semantic form approaches. And then this should pass the test. So couple things here. Number one, inside of our test.js file we have triggered an event change by calling fireEvent. And then we're using this nice combination of react testing library, where we have all of these queries with the expect that we have built in with jest. Lots of cool features are built directly into create react app and I encourage you to play around more with the testing library, documentation, to learn about all of the different features that you can make use of.

Deploying to Netlify

One of the tools that you can use to deploy your react application is Netlify. So let's go ahead and log in. You can log in with your GitHub account, GitLab, Bitbucket. You can create your own account with your email address. I'm just going to go ahead and log in with GitHub here. And since I'm logged in, it should pop me into this window and I'm going to click on add new site. So one of the options here is import an existing project. You could connect to your Git provider if you've already uploaded your project here that's kind of a quick way of getting started. But since we don't have GitHub set up for this particular project, I'm going to select deploy manually. What Netlify is looking for in this drag and drop window is the built version of our project. So let me show you how to do that. We're going to make sure that we're navigated to the finished react app location and we're going to run NPM run build. This is going to create a production build for our application, meaning that this will be optimized for production. It will have everything ready to go. This will generate what's called the build folder here. So what I can do inside of react app finished, is I can drag the build folder to this location. So, this will create a nice little URL for me. It's also going to build my project. So if I open this up in a new tab, check it out, we see our awesome website. So Netlify is a free tool that you can use to deploy a react application quickly and they make it kind of fun to work with because we can just drag and drop our project. And then we're ready to go right away. Now, from here you can customize all sorts of things. You could set up a custom domain, you could set up HTTPS support, but for now we should see our project running and it's running at this link.