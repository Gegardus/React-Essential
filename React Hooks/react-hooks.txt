REACT HOOKS

INTRO

Reviewing the project

In recent versions of React, react.StrictMode has been a wrapper that you can use on components. The benefit of wrapping your component with react.StrictMode is it's going to give you warnings. It's going to give you opportunities to fix possible bugs before they happen. So if you're in violation of any React rules, you're going to find out about it. So the next thing I want to do here is let's open up our app.js file. So this is our app component, kind of the main component that has been generated. Let's go ahead and get rid of everything inside of it. And then let's just add in each one here, and we'll say, "Hello World". And now as soon as we do that, it should immediately render to the browser. So that's really all we need in the way of setup. Again, our app component here is being rendered by the reactDOM.render. So here, we really have everything we need to get started.

USESTATE

Sending interactions up component trees

We've used React properties to get us this far, we've created a few different stars. Now, what we need to do is we need to handle clicking on them. In order to do this, we're going to create a state variable using useState. So we're still importing useState from React. And then if I scroll down a little bit to our star rating component, this is where I'm going to manage the state. So first we're going to create a constant here. We'll call this selectedStars and setSelectedStars. Those are long variable names, but they're descriptive so we'll stick with that. Or as an initial state we want to provide zero. So we'll say that when our component renders we don't want to have any of these be selected. Now we need to supply these properties to each one of the stars 'cause the star is actually the component that's being clicked. We want to make sure it has access to this state variable. So I can pass to the star here on line 22 a property called selected. This looks familiar from here. So selected here is going to set selectedStars is greater than i. So this is going to keep track based on the index of how many stars are selected. Then we're going to add this function called onSelect. So similar to our functions from before that changed state, we're going to need to use that setSelectedStars function. So let me scroll down a little bit. And inside of this function, let's go ahead and call setSelectedStars. And then how we want to select the star is by using its index plus one, because we're using a zero-based index in JavaScript, we need to make sure that we're capturing that correctly. Now, the final thing I need to do is I need to pass this function to each star, 'cause like I said that's where the clicking is actually going to happen. So first we'll pass the property. Then here on line 13 let's add the onClick, which'll just be set equal to onSelect. So that will call this setSelectedStars function. So now if we click on any one of these stars, it's going to capture that correctly. And then if I wanted to change the total stars to something a little more realistic, we can do so. And we see, let's zoom way in on that. And we see that every time I click one of those stars, the state changes, and we can make this even more clear if we want to by adding a fragment here around our createArray function. So let's first wrap it in a JSX expression. Then we're going to wrap this in a fragment. And now we can add, underneath the createArray function, a paragraph that says selectedStars of totalStars. Zero out of four, three out of four, four out of four. Pretty cool. So just to recap, we are managing our state with this function called useState, setSelectedStars is the function we use to change the state, and we've attached this to every single one of these stars so that as I click them it will change the application state.

USEEFFECT

Introducing useEffect

Another hook that is exported by the React library is useEffect. useEffect allows you to perform side effects in function components. So a side effect could be something like a console log, or it could interact with some kind of DOM API like history or window. So first we want to adjust our component here. So I'm going to get rid of everything related to our star. We had fun with our star rating, but it's time to move on. And then we're going to replace our star rating with a section. And the section will have a paragraph that says congratulations. And now we want to see that printed out. Perfect. So then we can use useEffect, but in order to use useEffect, we really need to set up a state variable. So first we'll set up a name and a function to change the state called setName. Then we'll call useState with some sort of an initial value. So the initial value we'll use here is Jan. Now, when we create that variable, we can then display the name inside of this string. Congratulations Jan. Then let's create a button. So the button is going to say change winner. So whoever is the winner will be reflected in the UI. Then we're going to add an onClick handler here and we'll pass in a function that's going to set the name. So it'll set the name to Will. So now when I changed the winner, it'll say congratulations Will. Now, this is all stuff we're familiar with because we've already used useState, but here's where useEffect comes in. So we're going to use this function called useEffect, and useEffect takes in a function. So it's going to look like this to get us started. Then we also need to be sure to import useEffect from React. Okay, so what we want useEffect to do is we want to have it change the document title. This is the default document title, React App, right here. So what I can do is I can just say document title equals celebrate name. So when I refresh, it says celebrate Jan, and then if I click change winner, it says congratulations Will. And also it's called this useEffect because it's changed the document title to reflect that. Now, by default, this runs after each render and every update, and this may not always be what you want. So in the next video, we'll learn how to customize when these useEffect functions fire.

Working with the dependency array

As we saw, every time we change the state, this useEffect call fires, but there's something that can help us out with this. So let's go ahead and pass another argument to this useEffect function, and the argument is just going to be an empty array. Notice how the name changes in the dom, but the effect is not called. So when we pass an empty array, it means that the effect will only fire once, on first render. You also can pass the name of the variable in here. So I could say name, and then when I change the winner, it will follow up by changing the document title. So this is particularly useful if you're dealing with more than one state variable. I'm going to change the document title to a console log message, and then I'll say celebrate name. We'll add another useEffect here. This will take in another function. And this time we'll say console.log, the user is, and we need to create another state variable, too. We'll call these admin and setAdmin, and then the initial state will be false. So this console log message is going to say the user is. We'll use a template here and we'll check the value of admin. If it's admin, we'll say admin. And then if not, we'll say not admin. Okay, so let's go back. And now we have two different state variables. Let's also add another paragraph and another button. So here on line 30, if it's an administrator, then return logged in. Otherwise, return not logged in. And then this button will say login. And then onClick should call that setAdmin function to change the state to true. Okay. So we have a lot of stuff going on here, and what we're noticing right away is that these have fired, these useEffect calls have fired on first render, but let's go ahead and remove this dependency array from our first useEffect. So I'll give that a save, celebrate Jan, user is not admin. So let's click the first one. We see the new state, celebrate Will, but we're still getting this message, too. So my desired effect here, no pun intended, is that if I change the winner, I only want to call this useEffect. So that's where the dependency array comes into play. We'll say, call this one any time the name changes. And then the second one here, we'll say call this one any time the admin changes. So now I change the winner, and we just logged celebrate Will. I changed login, and it just logs the second useEffect. So this dependency array is really useful. We don't want to be running code that we don't have to be. We want to be really specific about which effects should be called when, and we can help do so with this dependency array.

Fetching data with useEffect

Another use case for useEffect is for data fetching. So let's say we had an API like api.github.com/users so this is just a straight up rest API. It returned some Json data and we want to make a request for this data and then load it into our page. So the way I can do that is by using a combination of useState and useEffect. The first thing we'll do is we will update our component quite a bit and let's just start literally from scratch with this thing. So we'll still import useState and useEffect but inside of this app component now we want to create a state variable for data and setData. And then on first render we want useState the initial state just to be an empty array. So then we're going to say return a paragraph that says No Users. So now if we look at our app, it says No Users. It's going to be up to us to get the data from that API using a useEffect call, useEffect always takes in a function we're going to use fetch which takes in the URL of the API. So api.github.com/users, literally the same thing as this. once we've fetched, we need to call then and we'll take that response and we'll pass it as json so response.json the function should return that then, and here's what's real cool we can say .then, and we're going to call setData. So we could say response, setData with the response or we can just literally pass in setData. So that's kind of a shortcut that we can use if we'd like to. So if there's some data we want to return an unordered list we want to map over all these users and display their username. So we'll say data.map and then for each user, we want to add a list item and for each one of these list items we want to say user.username And it's not called username it's called login. Alright so let's try that again login and there we go. We also because we have the ids for all of these people we probably getting that dreaded error yap, so what we can do is we can say key equals user.id and that should be cleared, nice we're also getting this warning coming from react hooks telling us that we need to add a list of dependencies so that we don't have this infinite chain of updates. So there's a possibility every time we're using useEffects that if we don't handle the dependency array correctly then we're going to continuously make this useEffect call to that API we're going to add an empty array here to useEffect so that it's only called once on page load. Now what happens if we want to make this a little bit more interesting? Let's wrap our ul with a div so that we can add a button, and this button which will say Removed Data Let's add an on click to it and the on click is going to call setData and remember all these functions take in a new state. So our new state is going to be an empty array. I scroll to the bottom I say Remove Data and all the data is gone but what happens if I remove that dependency array? I'll scroll to the bottom again I'll say Remove Data. And it's constantly flickering it's constantly trying to load it again. So there's a bunch of extra HTTP requests going on here that are being caused by us not supplying this empty array. So that's how you use useEffect to load data and always remember that dependency array so you don't take down your APIs with too many HTTP requests.

ADDITIONAL HOOKS

Handling complex state with useReducer

In addition to useState, there's another way to manage state variables, and that is another one of these hooks called useReducer. So first, let's import useReducer, and we're going to do a little bit of cleanup here as usual. Instead of returning all that data, we're going to return just an h1, and the h1 should say a number. So the number that we want to display is going to relate to useReducer here. So let's say const number, and then setNumber. This is the function that's going to change the state. This is the state variable. But useReducer is going to look slightly different. Instead of taking in just an initial state, it's going to take in two arguments. So the first argument is actually a function, and the second argument is the initial state. So the initial state for this number is going to be zero. The function that we're going to send as the first argument to useReducer is going to be what we want to have happen when setNumber is called. So what we want to do is we want to take the number and the new number in as arguments, and then we want to return the number plus the new number. So that looks really bad until I save it, but there we go. We have our number and our newNumber. Zero is the initial state. So how do we know that this is going to work? Well, we're going to use that setNumber function in the onClick. So we'll say setNumber, and then we'll pass in one. And then every time I click on this h1, it's going to increment the number. It just takes in this number, it combines it with the old number, and it returns a new number. So this is how we're adding this together. So useReducer, again, it takes in two different things. First is a function that is going to return some sort of new state, and then an initial state is the second value. So in the next video, we'll take a look at a component that should look familiar, and we're going to refactor it using useReducer, so we can understand more of what's going on here.

Refactoring useState to useReducer

Earlier in the course, we created a checkbox, and we handled the checked state by using useState. So every time I click on this checkbox, we call the setChecked function, and then we look at whatever the value of checked is, and we return the opposite. We can refactor this a little bit using useReducer, which may help with potential bugs that could pop up just by kind of working on a team with other people. So if we build all the functionality into useReducer, we can minimize the amount that can go wrong. Instead of importing useState, let's import useReducer, and we'll replace it here. Now, the second thing I want to do is I want to call this function toggle, and then inside of the useReducer function, again, it takes in two things. It's going to take in that function that's going to change the state. So literally, I want to just pull this nice little function here. This is going to be my reducer. So let's paste that. Then, I'm going to say that false is the initial state. So instead of using setChecked in this onChange, we're going to replace this function with toggle. So now, it's going to work the exact same way. Now what's really nice about this is instead of having to embed this logic into all of these onChange events, we can sort of abstract this away into its own function. We know that every time we call toggle, we should do this. As your state gets more complex, it can be nice to consolidate your functionality into a useReducer call. This makes it a little easier to understand and a little easier to work with.

Dispatching actions with useReducer

Another pattern you can use with useReducer is to define a list of actions and then dispatch them in the component. So this will look a little different. We'll first start by adjusting our component. So inside of this component, we want to return a Message and we want this Message to display whatever the state of this message value is. Inside of the useReducer function, we're going to scaffold this to say a couple different things. So it's first going to take in the state. And then it's going to take in this method called dispatch. Then useReducer will take in a reducer and an initialState. So we'll define these outside of these parentheses. Now, the easier part of this to define the initialState. So let's go ahead and do that. The initialState here will be a message that says hi. So once we've created an initialState, that'll be passed into this function. Then we're going to go ahead and create a reducer. A reducer takes in state and an action and then it returns a new state. So the way that I can define which state it should return is with this switch statement. So the switch statement is going to take a look at whatever the type of the action is. This means that we can define the list of the possible actions that we could dispatch. So just think of an action as being like some sort of an event. We're going to send a yell action. And the yell action should return a message that says HEY! And we're yelling so all caps. Then we can specify a case for whispering. This time we'll return another object. Our message is excuse me. Very polite, very quiet. Now that we have our reducer defined, our message is displaying here, using our initialState. But what I'm really here to do is to try to dispatch some actions. So let's scroll down. We will add some UI elements that we can use to trigger these changes. So we'll say YELL. And here we're going to say onClick equals and again, we're going to dispatch an action of a specific type. And the type of action we want to dispatch is YELL. So this is what that'll look like. Type yell. There we go. And let's create another one of these buttons. It'll look pretty much identical, except it should say whisper. Let's make it all lowercase 'cause it very quiet. Then we'll say whisper. Inside of the action, and now I can say whisper and it'll say excuse me. Now, the reducer function takes in the state and an action and returns a new state. And while this is working okay, the real benefit of having access to that previous state is so that we can use it. So if our new state relies on the old state, this is a really good pattern to use. So I'm going to change this message to a template string and I'm going to say HEY! I JUST SAID state.message. So this is going to display whatever the previous state of message is. So now if I click on YELL again, it'll say HEY! I JUST SAID hi. So similarly, I could do the same here. So we could say excuse me, I just said state.message. So now if I click whisper, it should show me what the previous state was. So this can be really useful in calculations or checking in with the previous value to make sure that you're returning the new thing that's correct but this is what a reducer is for. It takes in the state and an action and it returns a new state and any time our state starts to become a little more complex, we can reach for useReducer to help us out.

Managing form inputs with useRef

As we move our way through all of these different hooks that the React library provides us with, one that we can't overlook is useRef. So useRef is going to allow us to reach out to a component and determine its value. And this can be extremely useful, particularly with forms. So the first thing I want to do with our form is I want to import useRef. I'll get rid of all of our reducer stuff from before. Then inside of the component, instead of returning this here, we're going to say form and we'll close the form. Inside the form, I want to add an input with a type of text and then we'll add another one of these with a type color. Then I need to get rid of useReducer because we're getting those errors. Let's just make sure that this is rendering okay. Yeah, so we have our little input fields and then we have a little color picker. Let's also create a button, and the button should have text that says add. So this is going to allow us to add a color. Now, what we really want to track in this case is we want to track whatever the user inputs into this field. So the thing that they'll input here, I'll add a placeholder, just for good measure. We want to catalog a sound and whatever we think the closest color to that sound might be. Now, if we want to be able to reach out to this form element and grab whatever the user types in, so screech or something like this, I need to be able to access this and capture it somewhere. So we're going to call useRef to find that. So we'll say const sound equals useRef and then const color equals useRef also. Now the way that we attach these to the form elements is we just add another attribute called ref and we attach that to whatever the name of the ref is. So ref equals color. Next, I need to handle submitting this form. I'm going to create a function called submit and this takes in the event, so the submission of the form. The reason I need this is because I want to prevent the default behavior of the page. In other words, I want to prevent the page from reloading as soon as I click that form. Now, in order to grab this value, like screech, what I need to do is I need to create another variable called sound value. This is going to be set equal to sound.current.value. And the .current.value is what's provided to us by this useRef function. So once we create one of these for the sound, we'll do one for color and then we'll say color.current.value. Now we want to not really do much with this but I just want to make sure that I can capture this value. So let's just alert it. So I'll say sound value sounds like color value. Okay, then I'm going to use this in the form. So I'll say on submit equals submit. Okay, so let's see if our alert is working. So our sound will be harp, and harp kind of sounds like maybe a yellowish color. I have to give that a lot of thought. So now the harp sounds like that color. So what's really cool about this is we're going to be able to check in with the values of these form elements. And at this point, all I'm doing is alerting them but you can think about how you might pass these off to your database or some other sort of external process that's running. You can capture user input. So now that I've alerted this, as soon as I saw that alert I still see the name and the color. So let's reset this. We can say sound.current.value equals empty string, color.current.value equals empty string also. So now if I try that again and I say screech and that's more of a red, I think, so we'll add that screech sounds like whatever, click okay. And all that's cleared out. So useRef is going to be particularly helpful when we're working with forms and you can use these to capture values from any input.

Creating controlled components with useState

Another way to handle inputs in a form is to use a controlled component. A controlled component means that you handle form inputs using state variables. So let's refactor our form component to make this work. Now here, instead of useRef, I want to use state. So it'll look like this sound and setSound equals useState and then this'll just be an empty string as its initial state. And then we'll say const color and setColor equals useState. And our initial state here will just be black. So it was zero zero, zero, zero, zero, zero. Now we can get rid of both uses of useRef and instead replace it with useState here. The next thing I need to do is let's adjust our component a little bit. So instead of ref sound it's going to be value sound. Instead of ref color, value color. Then we're going to add an on change event. This will take in E for the event and then we'll say setSound(e.target.value) Then we can use this same thing, but instead of setSound it's going to be setColor. So now our inputs are going to be in charge of changing the state. Now, the final thing we need to do here is let's remove any evidence of our refs here. And again, just to make sure that this is working, we want to check the sound and the color, and then upon submitting the form, we can reset the state. So I can say setSound is empty string. SetColor is zero, zero, zero, zero, zero, zero. Okay, so let's see how we're doing here. We have created these state variables for sound and color. We have adjusted our submit function to just alert whatever the sound and color in state are and then reset the sound in color when the form is submitted. And then each one of these inputs have their own onChange properties that change the state. So now what we can do is we can say screech and this time it'll be a green color. And now when I add it it should alert this and then clear it out. So there you have it. We're handling our form input values by assigning them to state values. In the next video, we'll take this one step further and abstract this functionality into a separate function.

CUSTOM HOOKS

Placing data in context

There are times when we want values to be available to the entire component tree. Instead of passing data up and down the tree, we can put the data in context so that all of the child components will know the values that are being passed down. So if you've worked with context in React before, this is kind of the new way to do it using React hooks. So let's go ahead and create a component that's going to consume some data from context. This is going to involve getting rid of our use input stuff. That served us well but we're ready to move on. And we also want to import createContext from react. Now, createContext is what we're going to use here. We're going to say export const TreesContext, so we're going to create this context. It's just like this little container where we're going to be able to store some data that can be consumed by any of the components that are part of the component tree. The data that we want to create here is going to be an array of objects and this is going to be super simple but we'll have an id for each one and a type: Maple. And I'll copy and paste a few of these, so I have four of them. The ids will be one, two, three, four, and then Oak, what are some other trees? Family tree. And Component tree. Cool. So now what we can do is we want to make all of this data accessible to our our entire app. I'm actually going to replace React.StrictMode. And I'm going to wrap my entire App component in the TreesContext.Provider. So this part, the name of the context, you create. You can call it whatever you want to. But then we use the Provider and Provider sounds like it is. It's just going to provide the data to the App component and anything nested below it. So now we need to supply a property called value and we're going to pass in the trees so that our component has access to that data. So once we supply that data via the value property, we can use the data inside of the component. So how do we access this data. Well, let's go ahead and adjust our app a little bit and we just want to say div h1. Eventually I want to display these trees that I've heard of and this will give me an array of these trees but if I moved this to a different file, it wouldn't know what those values were. In the next video, we're going to take a look at how we can use the data from this array that has been passed down via the provider inside of a nested component.

Retrieving data with useContext

In the previous video, we looked at how to pass data down to child components via the provider. In this video, we're going to learn to read from context using a hook. So, to make this work even nicer, let's move this app component out of the index, and we're going to move it to its own file. So here we're going to replace this function. We're going to then import it. So we'll say import app from app. And hopefully this will mimic what it's really like to work on a project with context a little bit more. So if we go back over to our app component, we need to take that data from context and make it accessible in this component. So, the way that we're going to do this, is we're going to import the trees context from .slash. So just that index file. Now, what we can do is we can pull in the use context hook from react. You might guess where this is going. We're going to call const, I'll say result equals use context. And then we'll pass in the name of the context that we're interested in. Let's then console log the result. I'm just curious about what this looks like. So this is returning an object that has trees as one of the keys. So now what I can do is I can destructure trees from that result. Then inside of the component, I can add an unordered list. I can map over trees. And then for each one of these trees, I want to return a list item. Each list item will have a type and maps is not a function, that's true, map is a function though, so let's fix that. That's working. We know that we have that key prop error, so let's fix that. So we'll say key equals tree.id, nice. So we've cleared out that warning, that's all good. We have displayed some data and we've pulled it in, using the use complex hook. So keep in mind that in any component, if we have a thousand components in our component tree, that's a lot of components, but you know what I mean? Any component that is part of the app, because it's been wrapped in the provider, we're going to be able to read the value of trees simply by calling use context.

Creating a custom Hook with context

It's also possible to create a custom hook to make this even more reusable. So what I want to do here on line one is import useContext into the index.js file. So we're here in index.js, and we're importing useContext. The second thing is we still will want to create the context, but we don't need to export it 'cause we won't be using it in a different file. What we will want to export is a constant called useTrees. Now, this is our custom hook. That's going to return useContext with the TreesContext. So this is going to make all of this data accessible to the component, but when we use it in the component, we're not going to call useContext with TreesContexts 'cause that's a lot of typing. All we really want to do is we want to say import useTrees from ./, and then we're going to call useTrees. So now the output is the same. All of the data is the same. I can get rid of useContext here. useTrees is simply going to allow us to reuse this functionality inside of components all over our app.

https://api.github.com/users/${login}
https://api.github.com/users/Gegardus